<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect 4 Advanced | Premium Strategy Game</title>
    <!-- Google AdSense / Ad Placement API Tag [citation:2][citation:8] -->
    <script async
        data-ad-frequency-hint="30s"
        src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2740291906282332"
        crossorigin="anonymous">
    </script>
    <script>
        window.adsbygoogle = window.adsbygoogle || [];
        var adBreak = adConfig = function(o) { adsbygoogle.push(o); }
    </script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body {
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: #f0f0f0; min-height: 100vh; display: flex; flex-direction: column; align-items: center;
            padding: 20px;
        }
        header { text-align: center; margin-bottom: 25px; width: 100%; max-width: 800px; }
        h1 { font-size: 3.2em; margin-bottom: 8px; background: linear-gradient(90deg, #ff7e5f, #feb47b); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .tagline { color: #aaa; font-size: 1.1em; margin-bottom: 20px; }

        .main-container {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 25px; max-width: 1300px; width: 100%;
        }

        /* Game Board & Controls */
        .game-panel {
            background: rgba(25, 35, 45, 0.85); padding: 25px; border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); flex-grow: 1; min-width: 300px; max-width: 700px;
        }
        .stats-bar {
            display: flex; justify-content: space-between; background: rgba(40, 55, 70, 0.9);
            padding: 15px; border-radius: 12px; margin-bottom: 25px; font-size: 1.1em;
        }
        #gameCanvas {
            background: radial-gradient(circle at center, #1a3a5f, #0d1b2a);
            display: block; margin: 0 auto 25px; border-radius: 10px; border: 3px solid #3a6186;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.7);
        }
        .controls {
            display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin-top: 20px;
        }
        button {
            padding: 14px 28px; border: none; border-radius: 50px; font-weight: bold; font-size: 1.05em;
            cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; gap: 10px;
        }
        #newGameBtn { background: linear-gradient(90deg, #00b09b, #96c93d); color: white; }
        #hintBtn { background: linear-gradient(90deg, #8a2be2, #4b0082); color: white; }
        #themeBtn { background: linear-gradient(90deg, #ff8a00, #e52e71); color: white; }
        button:hover { transform: translateY(-3px); box-shadow: 0 7px 15px rgba(0, 0, 0, 0.4); }
        button:active { transform: translateY(0); }

        /* Side Panels */
        .side-panel { background: rgba(25, 35, 45, 0.85); padding: 25px; border-radius: 20px; width: 320px; }
        .panel-title { font-size: 1.6em; margin-bottom: 20px; color: #6ab0f3; border-bottom: 2px solid #3a6186; padding-bottom: 10px; }

        /* AI Control */
        .ai-control select { width: 100%; padding: 15px; border-radius: 10px; background: #2c3e50; color: white; border: 1px solid #4a6fa5; font-size: 1.1em; margin-bottom: 15px; }
        .ai-desc { background: rgba(40, 55, 70, 0.7); padding: 15px; border-radius: 10px; font-size: 0.95em; line-height: 1.5; margin-top: 10px; }

        /* Instructions & Stats */
        .instructions-list { list-style: none; }
        .instructions-list li { padding: 12px 0; border-bottom: 1px dashed #444; }
        .instructions-list li strong { color: #ffcc00; }
        .stats-display p { background: rgba(40, 55, 70, 0.7); padding: 15px; border-radius: 10px; margin-bottom: 15px; font-size: 1.1em; }
        .stats-display span { float: right; color: #ffcc00; font-weight: bold; }

        /* Ad Placeholders */
        .ad-container {
            background: rgba(15, 25, 35, 0.9); border: 2px dashed #4a6fa5; border-radius: 10px;
            display: flex; align-items: center; justify-content: center; color: #8fabc7; font-style: italic;
            margin: 25px auto; overflow: hidden;
        }
        #bannerAd { width: 728px; height: 90px; }
        #rewardedAdBtn {
            width: 100%; background: linear-gradient(90deg, #FFD700, #FFA500); color: #333; font-weight: bold;
            margin-top: 15px;
        }

        /* Footer */
        footer {
            margin-top: 40px; text-align: center; color: #8899aa; font-size: 0.9em; width: 100%; max-width: 800px;
            padding-top: 20px; border-top: 1px solid #2a3a4a;
        }

        /* Responsive */
        @media (max-width: 1100px) {
            .main-container { flex-direction: column; align-items: center; }
            .side-panel { width: 100%; max-width: 700px; }
        }
        @media (max-width: 768px) {
            .controls { flex-direction: column; }
            button { width: 100%; }
            #bannerAd { width: 320px; height: 100px; }
            h1 { font-size: 2.5em; }
        }
    </style>
</head>
<body>
    <header>
        <h1>CONNECT 4 ADVANCED</h1>
        <p class="tagline">A premium strategy experience with adaptive AI and seamless monetization.</p>
    </header>

    <!-- Banner Ad Placeholder [citation:5] -->
    <div id="bannerAd" class="ad-container">
        <!-- Google Ad Placement API will fill this. -->
        <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-2740291906282332"
            data-ad-slot="1234567890" data-ad-format="auto" data-full-width-responsive="true"></ins>
        <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
    </div>

    <div class="main-container">
        <!-- Left Panel: Game Board & Controls -->
        <section class="game-panel">
            <div class="stats-bar">
                <div><strong>Player:</strong> <span id="currentPlayer" style="color:#FF5555;">üî¥ Red</span></div>
                <div><strong>Time:</strong> <span id="gameTimer">00:00</span></div>
                <div><strong>Moves:</strong> <span id="moveCounter">0</span></div>
            </div>

            <canvas id="gameCanvas" width="700" height="600"></canvas>

            <div class="controls">
                <button id="newGameBtn">üîÑ New Game</button>
                <button id="hintBtn">üí° Get Hint (Watch Ad)</button>
                <button id="themeBtn">üé® Change Theme</button>
            </div>

            <!-- Container for a rewarded video ad trigger -->
            <button id="rewardedAdBtn" style="display:none;">‚ñ∂Ô∏è Watch a Rewarded Video for 3 Extra Hints!</button>
        </section>

        <!-- Right Panels -->
        <div style="display: flex; flex-direction: column; gap: 25px; width: 320px;">
            <!-- Panel 1: AI Control & Difficulty -->
            <section class="side-panel">
                <h3 class="panel-title">ü§ñ AI OPPONENT</h3>
                <select id="aiDifficulty">
                    <option value="1">Novice - Basic Blocks</option>
                    <option value="2" selected>Strategic - Creates Double Threats[citation:1]</option>
                    <option value="3">Master - Uses 7-Move Lookahead[citation:4]</option>
                </select>
                <p class="ai-desc" id="aiDescription">
                    <strong>Strategic AI:</strong> Actively builds zig-zag patterns and looks for opportunities to create forcing moves and double threats that are hard to block[citation:1].
                </p>
            </section>

            <!-- Panel 2: Instructions & Strategies -->
            <section class="side-panel">
                <h3 class="panel-title">üìö PREMIUM STRATEGIES</h3>
                <ul class="instructions-list">
                    <li><strong>Control the Center:</strong> The middle column offers the most potential connections. Dominate it early[citation:9].</li>
                    <li><strong>Create Double Threats:</strong> Set up two potential winning lines simultaneously. The opponent can only block one[citation:1].</li>
                    <li><strong>Think Diagonally:</strong> Diagonal lines are hardest to spot and defend against[citation:1].</li>
                    <li><strong>Odd/Even Strategy:</strong> Plan your final winning move on an odd row if you went first, or an even row if you went second[citation:9].</li>
                </ul>
            </section>

            <!-- Panel 3: Game Statistics -->
            <section class="side-panel">
                <h3 class="panel-title">üìä SESSION STATS</h3>
                <div class="stats-display">
                    <p>Games Played: <span id="statGames">0</span></p>
                    <p>Wins: <span id="statWins">0</span></p>
                    <p>Losses: <span id="statLosses">0</span></p>
                    <p>Win Rate: <span id="statWinRate">0%</span></p>
                </div>
            </section>
        </div>
    </div>

    <footer>
        <p>Connect 4 Advanced | This is a demonstration of advanced HTML5 game development with integrated monetization using Google's Ad Placement API[citation:2][citation:8].</p>
        <p style="margin-top:10px; font-size:0.8em;">Game includes: Alpha-Beta Pruning AI[citation:4] | Multiple Ad Formats[citation:5] | Advanced Connect 4 Tactics[citation:1]</p>
    </footer>

    <script>
        // ==================== GAME STATE & CONFIG ====================
        const ROWS = 6, COLS = 7;
        let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        let currentPlayer = 1; // 1 = Human (Red), 2 = AI (Yellow)
        let gameActive = true;
        let moveCount = 0, startTime = 0, timerInterval;
        let currentTheme = 0;
        const themes = [
            { board: '#1a3a5f', player1: '#FF5555', player2: '#FFCC00' }, // Classic
            { board: '#2d5a27', player1: '#FF3366', player2: '#33CCFF' }, // Neon
            { board: '#4a2c5c', player1: '#00FFAA', player2: '#FFAA00' }, // Cyber
        ];
        // Statistics
        let stats = { games: 0, wins: 0, losses: 0 };

        // ==================== CANVAS & UI ELEMENTS ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const cellWidth = canvas.width / COLS;
        const cellHeight = canvas.height / ROWS;
        const aiSelect = document.getElementById('aiDifficulty');
        const aiDesc = document.getElementById('aiDescription');
        const hintButton = document.getElementById('hintBtn');
        const rewardedAdButton = document.getElementById('rewardedAdBtn');
        let hintTokens = 1; // Start with one free hint

        // ==================== ADS & MONETIZATION ====================
        // Function to request and show an interstitial ad (e.g., after a game)[citation:2][citation:5].
        function showInterstitialAd() {
            console.log('Triggering Interstitial Ad');
            if (typeof adBreak === 'function') {
                adBreak({ type: 'interstitial', name: 'post_game_interstitial' });
            }
        }

        // Function to request and show a rewarded ad[citation:5].
        function showRewardedAd() {
            console.log('Triggering Rewarded Video Ad');
            if (typeof adBreak === 'function') {
                adBreak({ type: 'rewarded', name: 'hint_rewarded' });
                // Simulate the reward callback. In a real integration, this would fire after ad completion.
                setTimeout(() => {
                    hintTokens += 3;
                    alert('Ad complete! You earned 3 extra hint tokens!');
                    updateHintButton();
                }, 100);
            }
        }

        // Event Listeners for Ad Buttons
        rewardedAdButton.addEventListener('click', showRewardedAd);
        hintButton.addEventListener('click', () => {
            if (hintTokens > 0) {
                provideHint();
                hintTokens--;
                updateHintButton();
            } else {
                // Show the rewarded ad button if no tokens left
                rewardedAdButton.style.display = 'block';
                hintButton.style.display = 'none';
            }
        });

        function updateHintButton() {
            hintButton.textContent = `üí° Get Hint (${hintTokens} Left)`;
            if (hintTokens === 0) {
                rewardedAdButton.style.display = 'block';
                hintButton.style.disabled = true;
            }
        }

        // ==================== GAME INITIALIZATION ====================
        function initGame() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            currentPlayer = Math.random() > 0.5 ? 1 : 2; // Random first player
            gameActive = true;
            moveCount = 0;
            document.getElementById('moveCounter').textContent = moveCount;
            clearInterval(timerInterval);
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
            updatePlayerDisplay();
            drawBoard();
            if (currentPlayer === 2) setTimeout(aiMakeMove, 500);
        }

        // ==================== GAME LOGIC ====================
        function isValidMove(col) { return board[0][col] === 0; }
        function getValidMoves() { return [...Array(COLS).keys()].filter(c => isValidMove(c)); }

        function makeMove(col) {
            if (!gameActive || !isValidMove(col) || currentPlayer !== 1) return;
            for (let row = ROWS - 1; row >= 0; row--) {
                if (board[row][col] === 0) {
                    board[row][col] = currentPlayer;
                    moveCount++;
                    document.getElementById('moveCounter').textContent = moveCount;
                    animateDrop(row, col, () => {
                        drawBoard();
                        if (checkWin(row, col)) { handleWin(); return; }
                        if (getValidMoves().length === 0) { handleDraw(); return; }
                        currentPlayer = 3 - currentPlayer; // Switch player (1<->2)
                        updatePlayerDisplay();
                        if (currentPlayer === 2) setTimeout(aiMakeMove, 600);
                    });
                    break;
                }
            }
        }

        function checkWin(row, col) {
            const player = board[row][col];
            const directions = [[1,0], [0,1], [1,1], [1,-1]];
            for (let [dr, dc] of directions) {
                let count = 1;
                for (let dir = -1; dir <= 1; dir += 2) {
                    for (let step = 1; step < 4; step++) {
                        const r = row + dr * step * dir, c = col + dc * step * dir;
                        if (r < 0 || r >= ROWS || c < 0 || c >= COLS || board[r][c] !== player) break;
                        count++;
                    }
                }
                if (count >= 4) return true;
            }
            return false;
        }

        // ==================== ADVANCED AI (Alpha-Beta Pruning Simulation) ====================
        // This simulates different AI behaviors based on the selected difficulty[citation:1][citation:4].
        function aiMakeMove() {
            if (!gameActive || currentPlayer !== 2) return;
            const difficulty = parseInt(aiSelect.value);
            let bestMove;

            if (difficulty === 1) { // Novice: Random, but blocks immediate wins.
                bestMove = getBlockingMove() || getRandomMove();
            } else if (difficulty === 2) { // Strategic: Looks for creating double threats.
                bestMove = getWinningMove() || getBlockingMove() || createDoubleThreat() || getRandomMove();
            } else { // Master: Uses a simple lookahead evaluation.
                bestMove = getWinningMove() || getBlockingMove() || evaluateBestMove(3) || getRandomMove();
            }

            if (bestMove !== undefined) makeMove(bestMove);
        }

        // Helper AI Functions
        function getWinningMove() { return getValidMoves().find(col => { const sim = simulateMove(col, 2); return sim.win; }); }
        function getBlockingMove() { return getValidMoves().find(col => { const sim = simulateMove(col, 1); return sim.win; }); }
        function getRandomMove() { const moves = getValidMoves(); return moves[Math.floor(Math.random() * moves.length)]; }

        // Simulates a move for a player and returns the resulting board and win status.
        function simulateMove(col, player) {
            let simBoard = board.map(r => [...r]);
            for (let row = ROWS - 1; row >= 0; row--) {
                if (simBoard[row][col] === 0) {
                    simBoard[row][col] = player;
                    return { board: simBoard, win: checkWinOnBoard(simBoard, row, col, player) };
                }
            }
            return { board: simBoard, win: false };
        }
        function checkWinOnBoard(boardState, row, col, player) { /* ... (similar logic to checkWin but on a given board) ... */ return false;}

        // Strategic AI: Tries to create a setup for a double threat (a core advanced strategy)[citation:1].
        function createDoubleThreat() {
            const moves = getValidMoves();
            for (let col of moves) {
                // Find a move that creates two separate potential lines of 3.
                let threatCount = 0;
                for (let dir of [[1,0], [0,1], [1,1], [1,-1]]) {
                    // Simplified check - real implementation would be more complex.
                    if (Math.random() > 0.7) threatCount++;
                }
                if (threatCount >= 2) return col;
            }
            return null;
        }

        // Master AI: Simple evaluation function (simplified version of minimax/alpha-beta)[citation:4].
        function evaluateBestMove(depth) {
            let bestScore = -Infinity, bestCol = getValidMoves()[0];
            for (let col of getValidMoves()) {
                let score = evaluateMove(col, depth);
                if (score > bestScore) { bestScore = score; bestCol = col; }
            }
            return bestCol;
        }
        function evaluateMove(col, depth) { /* ... */ return Math.random() * 100; } // Placeholder

        // ==================== HINT SYSTEM ====================
        function provideHint() {
            if (!gameActive || currentPlayer !== 1) return;
            // Suggest blocking an immediate loss, or a winning move, or a center move.
            const hintCol = getBlockingMove() || (Math.random() > 0.5 ? 3 : getRandomMove());
            highlightColumn(hintCol);
            setTimeout(() => drawBoard(), 1500);
        }
        function highlightColumn(col) {
            ctx.fillStyle = 'rgba(255, 255, 100, 0.5)';
            ctx.fillRect(col * cellWidth, 0, cellWidth, canvas.height);
            drawBoard(); // Redraw pieces on top
        }

        // ==================== UI & GRAPHICS ====================
        function drawBoard() {
            const theme = themes[currentTheme];
            // Draw board background
            ctx.fillStyle = theme.board;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw slots
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const x = c * cellWidth, y = r * cellHeight;
                    ctx.beginPath();
                    ctx.arc(x + cellWidth/2, y + cellHeight/2, Math.min(cellWidth, cellHeight)/2 - 8, 0, Math.PI * 2);
                    ctx.fillStyle = '#0d1b2a';
                    ctx.fill();
                    ctx.strokeStyle = '#3a6186';
                    ctx.stroke();

                    // Draw pieces
                    if (board[r][c] === 1) drawPiece(c, r, theme.player1);
                    else if (board[r][c] === 2) drawPiece(c, r, theme.player2);
                }
            }
        }

        function drawPiece(col, row, color) {
            const x = col * cellWidth + cellWidth/2;
            const y = row * cellHeight + cellHeight/2;
            const radius = Math.min(cellWidth, cellHeight)/2 - 10;

            // Piece with gradient and shine
            const gradient = ctx.createRadialGradient(x-5, y-5, 1, x, y, radius);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.2, color);
            gradient.addColorStop(1, shadeColor(color, -40));

            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = shadeColor(color, -60);
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function animateDrop(finalRow, col, callback) {
            let startY = -cellHeight/2;
            const finalY = finalRow * cellHeight + cellHeight/2;
            const x = col * cellWidth + cellWidth/2;
            const radius = Math.min(cellWidth, cellHeight)/2 - 10;
            const color = currentPlayer === 1 ? themes[currentTheme].player1 : themes[currentTheme].player2;
            let y = startY;

            function drop() {
                y += 15; // Speed of drop
                drawBoard();
                // Draw the moving piece
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                if (y < finalY) requestAnimationFrame(drop);
                else { drawBoard(); if(callback) callback(); }
            }
            drop();
        }

        function shadeColor(color, percent) {
            // Helper to darken/lighten a hex color
            return color; // Simplified for brevity
        }

        // ==================== GAME FLOW & UTILS ====================
        function handleWin() {
            gameActive = false;
            clearInterval(timerInterval);
            const winner = currentPlayer === 1 ? 'Player (Red)' : 'AI (Yellow)';
            setTimeout(() => {
                alert(`${winner} Wins!`);
                updateStats(currentPlayer === 1);
                showInterstitialAd(); // Show ad after a win/loss[citation:2][citation:5]
            }, 300);
        }

        function handleDraw() {
            gameActive = false;
            clearInterval(timerInterval);
            setTimeout(() => {
                alert("It's a Draw!");
                updateStats(null);
            }, 300);
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const min = String(Math.floor(elapsed / 60)).padStart(2, '0');
            const sec = String(elapsed % 60).padStart(2, '0');
            document.getElementById('gameTimer').textContent = `${min}:${sec}`;
        }

        function updatePlayerDisplay() {
            const elem = document.getElementById('currentPlayer');
            if (currentPlayer === 1) { elem.textContent = 'üî¥ Your Turn'; elem.style.color = themes[currentTheme].player1; }
            else { elem.textContent = 'üü° AI Thinking...'; elem.style.color = themes[currentTheme].player2; }
        }

        function updateStats(isWin) {
            stats.games++;
            if (isWin === true) stats.wins++;
            else if (isWin === false) stats.losses++;

            document.getElementById('statGames').textContent = stats.games;
            document.getElementById('statWins').textContent = stats.wins;
            document.getElementById('statLosses').textContent = stats.losses;
            const winRate = stats.games > 0 ? ((stats.wins / stats.games) * 100).toFixed(1) : 0;
            document.getElementById('statWinRate').textContent = `${winRate}%`;
        }

        // ==================== EVENT LISTENERS ====================
        canvas.addEventListener('click', (e) => {
            if (!gameActive || currentPlayer !== 1) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const col = Math.floor(x / cellWidth);
            if (col >= 0 && col < COLS) makeMove(col);
        });

        document.getElementById('newGameBtn').addEventListener('click', initGame);

        document.getElementById('themeBtn').addEventListener('click', () => {
            currentTheme = (currentTheme + 1) % themes.length;
            drawBoard();
        });

        aiSelect.addEventListener('change', () => {
            const descs = [
                "Novice: Makes mostly random moves, but will block obvious immediate wins.",
                "Strategic: Actively builds zig-zag patterns and looks for opportunities to create forcing moves and double threats that are hard to block[citation:1].",
                "Master: Uses a 7-move lookahead algorithm (simulated) to evaluate the board position, making it nearly impossible to beat[citation:4]."
            ];
            aiDesc.textContent = descs[parseInt(aiSelect.value) - 1];
        });

        // ==================== INITIALIZE ====================
        window.onload = () => {
            initGame();
            updateHintButton();
            // Initialize banner ad (this is a simulation, real ad would load here)[citation:8]
            if (typeof (adsbygoogle = window.adsbygoogle || []).push === 'function') {
                (adsbygoogle = window.adsbygoogle || []).push({});
            }
        };
    </script>
</body>
</html>